# -*- coding: utf-8 -*-
"""
File ini berisi generator untuk skrip Checkpoint Management CLI.
"""
import io
from collections import defaultdict

from models import FirewallConfig, Address, Group, Service, ServiceGroup, Rule, TimeRange, NatRule, StaticRoute, \
    Interface
from .base import BaseGenerator


class CheckpointGenerator(BaseGenerator):
    """Generator untuk skrip Checkpoint Management CLI."""
    WELL_KNOWN_PORTS = {
        'ftp': '21', 'ssh': '22', 'telnet': '23', 'smtp': '25',
        'domain': '53', 'www': '80', 'http': '80', 'https': '443',
        'pop3': '110', 'imap4': '143', 'ldap': '389', 'ldaps': '636',
        'rsh': '514', 'syslog': '514', 'netbios-ns': '137',
        'netbios-dgm': '138', 'netbios-ssn': '139',
        'snmp': '161', 'snmptrap': '162', 'nfs': '2049', 'sqlnet': '1521', 'ntp': '123',
        'isakmp': '500', 'traceroute': '33434-33534'
    }

    def __init__(self, config: FirewallConfig, **kwargs):
        super().__init__(config, **kwargs)
        # [NEW] Target Layout (Aggregates)
        self.target_layout = kwargs.get('target_layout', [])
        # [NEW] Interface Mapping for renaming
        self.interface_mapping = kwargs.get('interface_mapping', {})

    def _translate_port_string(self, port_def: str) -> str:
        if not port_def: return ""
        parts = port_def.split()
        translated_parts = [self.WELL_KNOWN_PORTS.get(p.lower(), p) for p in parts]
        if len(translated_parts) > 1:
            if translated_parts[0].lower() == 'eq': return translated_parts[1]
            if translated_parts[0].lower() == 'range': return "{}-{}".format(translated_parts[1], translated_parts[2])
        return "-".join(translated_parts)

    def generate(self) -> str:
        output = io.StringIO()
        output.write("#!/bin/bash\n")
        output.write("# Check Point Management CLI Script generated by Firewall Converter\n")
        output.write("# Note: This script creates objects and rules on the Management Server.\n")
        output.write("# Interface configuration below is for Gaia OS (Clish) reference.\n\n")

        self._generate_interfaces(output)
        self._generate_addresses(output)
        self._generate_address_groups(output)
        self._generate_services(output)
        self._generate_service_groups(output)
        self._generate_static_routes(output)
        self._generate_rules(output)
        self._generate_nat_rules(output)

        output.write("\n# Publish the changes\n")
        output.write("mgmt_cli publish\n")
        return output.getvalue()

    def _generate_interfaces(self, f):
        """Men-generate perintah untuk membuat interface."""
        if not self.config.interfaces and not self.target_layout: return
        
        # [NEW] Helper to get mapped interface name
        def get_mapped_name(original_name):
            if original_name in self.interface_mapping:
                val = self.interface_mapping[original_name]
                if isinstance(val, dict):
                     val = val.get('target_interface')

                if val and str(val).strip():
                    return val
            return original_name
        
        f.write("# --- Interface (Gaia OS Reference) ---\n")
        f.write("# Copy and paste these commands into the Gateway CLI (Clish) if needed.\n")
        
        # [NEW] Generate Aggregate (Bonding) Interfaces
        bond_members = set()
        for agg in self.target_layout:
            name = agg.get('name')
            members = agg.get('members', '')
            if not name: continue
            
            # Ensure name starts with 'bond' for Checkpoint convention usually
            # But we respect user input.
            
            member_list = [m.strip() for m in members.split(',') if m.strip()]
            bond_members.update(member_list)
            
            f.write(f"# add bonding group {name.replace('bond', '')} interface {' interface '.join(member_list)}\n")
            f.write(f"# set bonding group {name.replace('bond', '')} mode 8023AD\n") # Default to LACP
        
        f.write("\n# --- Interface (Management Objects) ---\n")

        # Kelompokkan subinterface di bawah interface induknya
        sub_interfaces = defaultdict(list)
        main_interfaces = []
        
        for iface in self.config.interfaces:
            # Skip if it's a member of a bond (handled by bond config in OS)
            if iface.name in bond_members:
                continue

            if '.' in iface.name:
                parent = iface.name.split('.')[0]
                sub_interfaces[parent].append(iface)
            else:
                main_interfaces.append(iface)

        for iface in sorted(main_interfaces, key=lambda x: x.name):
            # [FIXED] Interface name is ALREADY renamed by app.py, use it directly
            if iface.ip_address and iface.mask_length:
                cmd = f'mgmt_cli set-interface name "{iface.name}" ipv4-address {iface.ip_address} ipv4-mask-length {iface.mask_length}'
                if iface.description:
                    cmd += f' comments "{iface.description}"'
                f.write(cmd + "\n")

        for parent, subs in sub_interfaces.items():
            # [FIXED] Parent and subinterface names are ALREADY renamed by app.py
            for sub_iface in sorted(subs, key=lambda x: x.name):
                if sub_iface.vlan_id:
                    f.write(f'mgmt_cli add-vlan-interface name "{parent}" vlan-id {sub_iface.vlan_id}\n')
                if sub_iface.ip_address and sub_iface.mask_length:
                    cmd = f'mgmt_cli set-interface name "{sub_iface.name}" ipv4-address {sub_iface.ip_address} ipv4-mask-length {sub_iface.mask_length}'
                    if sub_iface.description:
                        cmd += f' comments "{sub_iface.description}"'
                    f.write(cmd + "\n")
        f.write("\n")

    def _generate_static_routes(self, f):
        """Men-generate perintah rute statis untuk Checkpoint."""
        if not self.config.static_routes: return
        f.write("# --- Routes ---\n")
        for route in self.config.static_routes:
            # Handle Dynamic Route placeholders from Cisco ASA parser
            if route.next_hop == "Dynamic-OSPF" or route.next_hop == "Dynamic-BGP":
                f.write(f"# [DYNAMIC ROUTE DETECTED] Network: {route.destination} (Originally {route.interface.upper()}). Please configure dynamic routing protocol manually.\n")
                continue

            try:
                dest_ip, cidr = route.destination.split('/')
                f.write(
                    f"mgmt_cli add static-route network {dest_ip} mask-length {cidr} next-hop-gateway {route.next_hop}\n")
            except (ValueError, TypeError):
                f.write(f"# SKIPPED INVALID ROUTE: {route}\n")
        f.write("\n")

    def _generate_addresses(self, f):
        if not self.config.addresses: return
        f.write("# --- Object Address ---\n")
        for addr in sorted(self.config.addresses, key=lambda x: x.name):
            if addr.type == 'host':
                f.write('mgmt_cli add host name "{}" ip-address "{}"\n'.format(addr.name, addr.value1))
            elif addr.type == 'network':
                f.write('mgmt_cli add network name "{}" subnet "{}" mask-length "{}"\n'.format(addr.name, addr.value1,
                                                                                               addr.value2))
            elif addr.type == 'range':
                f.write(
                    'mgmt_cli add address-range name "{}" range-from "{}" range-to "{}"\n'.format(addr.name,
                                                                                                  addr.value1,
                                                                                                  addr.value2))
        f.write("\n")

    def _generate_services(self, f):
        if not self.config.services: return
        f.write("# --- Object Service ---\n")
        for svc in sorted(self.config.services, key=lambda x: x.name):
            protocol = svc.protocol.upper()
            if protocol in ["TCP", "UDP"]:
                port_range = self._translate_port_string(svc.port)
                if port_range:
                    f.write(
                        'mgmt_cli add service-{} name "{}" port "{}"\n'.format(protocol.lower(), svc.name, port_range))
            elif protocol == "ICMP":
                f.write('mgmt_cli add service-icmp name "{}"\n'.format(svc.name))
        f.write("\n")

    def _generate_address_groups(self, f):
        if not self.config.address_groups: return
        f.write("# --- Address Group ---\n")
        for grp in sorted(self.config.address_groups, key=lambda x: x.name):
            members_str = " ".join(['"{}"'.format(m) for m in sorted(list(grp.members))])
            if members_str:
                f.write('mgmt_cli add group name "{}" members {}\n'.format(grp.name, members_str))
        f.write("\n")

    def _generate_service_groups(self, f):
        if not self.config.service_groups: return
        f.write("# --- Service Group ---\n")
        for grp in sorted(self.config.service_groups, key=lambda x: x.name):
            members_str = " ".join(['"{}"'.format(m) for m in sorted(list(grp.members))])
            if members_str:
                f.write('mgmt_cli add service-group name "{}" members {}\n'.format(grp.name, members_str))
        f.write("\n")

    def _generate_rules(self, f):
        if not self.config.rules: return
        f.write("# --- Security Policy ---\n")
        f.write(
            "# IMPORTANT: 'layer' parameter below is set to 'Network'. Change it to match your Policy Layer Name.\n")

        dnat_reverse_map = {}
        for nat_rule in self.config.nat_rules:
            if nat_rule.translated_destination and nat_rule.original_destination:
                dnat_reverse_map[nat_rule.translated_destination] = list(nat_rule.original_destination)[0]

        for rule in self.config.rules:
            src_list = sorted(list(rule.source))
            if not src_list or 'any' in {s.lower() for s in src_list}:
                src_members_str = '"Any"'
            else:
                src_members_str = " ".join(['"{}"'.format(m) for m in src_list])

            final_destinations = set()
            for dest_object in rule.destination:
                if dest_object in dnat_reverse_map:
                    final_destinations.add(dnat_reverse_map[dest_object])
                else:
                    final_destinations.add(dest_object)

            dst_list = sorted(list(final_destinations))

            if not dst_list or 'any' in {d.lower() for d in dst_list}:
                dst_members_str = '"Any"'
            else:
                dst_members_str = " ".join(['"{}"'.format(m) for m in dst_list])

            svc_list = sorted(list(rule.service))
            app_list = sorted(list(rule.application))

            final_services = set()

            if app_list:
                final_services.update(app_list)
                is_app_default = 'application-default' in {s.lower() for s in svc_list}
                if not is_app_default and svc_list and 'any' not in {s.lower() for s in svc_list}:
                    final_services.update(svc_list)
            else:
                final_services.update(svc_list)

            final_services_list = sorted(list(final_services))
            if not final_services_list or 'any' in {s.lower() for s in
                                                    final_services_list} or 'application-default' in {s.lower() for s in
                                                                                                      final_services_list}:
                svc_members_str = '"Any"'
            else:
                svc_members_str = " ".join(['"{}"'.format(s) for s in final_services_list])

            action = "Accept" if rule.action == 'allow' else "Drop"
            enabled_str = "true" if rule.enabled else "false"

            # FIX: Hapus hardcoded 'layer' atau buat menjadi variabel yang mudah diganti user
            # Di sini saya ubah agar menggunakan placeholder yang jelas
            cmd = 'mgmt_cli add access-rule layer "Network" position bottom name "{}" '.format(rule.name)
            cmd += 'action "{}" source {} destination {} '.format(action, src_members_str, dst_members_str)
            cmd += 'service {} enabled "{}" track "Log"'.format(svc_members_str, enabled_str)

            if rule.remark:
                clean_remark = rule.remark.replace('"', "'")
                cmd += ' comments "{}"'.format(clean_remark)

            f.write(cmd + "\n")
        f.write("\n")

    def _generate_nat_rules(self, f):
        if not self.config.nat_rules: return
        f.write("# --- NAT ---\n")
        f.write(
            "# IMPORTANT: 'package' parameter below is set to 'Standard'. Change it to match your Policy Package Name.\n")
        for rule in self.config.nat_rules:
            # FIX: Beri warning atau variabel untuk package name
            cmd = 'mgmt_cli add nat-rule package "Standard" position bottom'

            if rule.original_source and 'any' not in {s.lower() for s in rule.original_source}:
                src = list(rule.original_source)[0]
                cmd += ' original-source "{}"'.format(src)
            else:
                cmd += ' original-source "Any"'

            if rule.original_destination and 'any' not in {d.lower() for d in rule.original_destination}:
                dst = list(rule.original_destination)[0]
                cmd += ' original-destination "{}"'.format(dst)
            else:
                cmd += ' original-destination "Any"'

            if rule.original_service and 'any' not in {s.lower() for s in rule.original_service}:
                svc = list(rule.original_service)[0]
                cmd += ' original-service "{}"'.format(svc)
            else:
                cmd += ' original-service "Any"'

            if rule.translated_source:
                cmd += ' translated-source "{}"'.format(rule.translated_source)
            if rule.translated_destination:
                cmd += ' translated-destination "{}"'.format(rule.translated_destination)
            if rule.translated_service:
                cmd += ' translated-service "{}"'.format(rule.translated_service)

            enabled_str = "true" if rule.enabled else "false"
            cmd += ' enabled "{}"'.format(enabled_str)

            if rule.remark:
                clean_remark = rule.remark.replace('"', "'")
                cmd += ' comments "{}"'.format(clean_remark)

            f.write(cmd + "\n")
        f.write("\n")