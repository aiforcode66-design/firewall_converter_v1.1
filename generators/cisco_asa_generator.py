# -*- coding: utf-8 -*-
"""
File ini berisi generator untuk konfigurasi Cisco ASA.
Updated:
1. Menggunakan format header '#' agar kompatibel dengan navigasi UI.
2. Menambahkan fitur Sanitasi Nama (_eq removal) untuk nama object yang lebih bersih.
3. Menambahkan dukungan Mapping Interface/Zone via kwargs.
4. FIXED: Subinterface generation (vlan id extraction) for port-channel/ethernet subinterfaces.
5. FIXED: Nameif generation logic to strictly follow zone or sanitized interface name.
6. FIXED [CRITICAL]: Security ACLs now correctly use Post-NAT (Real IP) for Destination Address
   when DNAT is involved, complying with Cisco ASA 8.3+ architecture.
"""
import io
import re
from collections import defaultdict

from models import FirewallConfig, Address, Group, Service, ServiceGroup, Rule, TimeRange, NatRule, StaticRoute, \
    Interface
from .base import BaseGenerator


class CiscoAsaGenerator(BaseGenerator):
    """Generator untuk skrip konfigurasi Cisco ASA."""

    _APP_TO_SERVICE_MAP = {
        "ssl": Service(name="tcp-443", protocol="tcp", port="eq 443"),
        "https": Service(name="tcp-443", protocol="tcp", port="eq 443"),
        "http": Service(name="tcp-80", protocol="tcp", port="eq 80"),
        "web-browsing": Service(name="tcp-80", protocol="tcp", port="eq 80"),
        "ssh": Service(name="tcp-22", protocol="tcp", port="eq 22"),
        "ftp": Service(name="tcp-21", protocol="tcp", port="eq 21"),
        "dns": Service(name="udp-53", protocol="udp", port="eq 53"),
    }

    def __init__(self, config: FirewallConfig, **kwargs):
        super().__init__(config, **kwargs)
        # Menyimpan mapping jika diperlukan untuk logika spesifik (walaupun app.py sudah memproses config)
        self.interface_mapping = kwargs.get('interface_mapping', {})
        self.zone_mapping = kwargs.get('zone_mapping', {})

    def _sanitize_name(self, name: str) -> str:
        """
        Membersihkan nama objek.
        1. Mengganti spasi dengan underscore.
        2. Menghapus artefak '_eq' atau '-eq' dari parsing.
        3. Menghindari double dash.
        """
        if not name:
            return ""

        # Basic replacement untuk karakter ilegal umum
        safe_name = re.sub(r'[^\w\.\-\_]', '_', name.strip())

        # Fix Service Naming Artifacts (Permintaan User)
        # Contoh: TCP_eq-19780 -> TCP-19780
        safe_name = safe_name.replace("_eq", "").replace("-eq", "")

        # Remove Double Dashes yang mungkin muncul setelah replace
        while "--" in safe_name:
            safe_name = safe_name.replace("--", "-")

        return safe_name

    def generate(self) -> str:
        """Menghasilkan skrip Cisco ASA lengkap."""
        output = io.StringIO()
        # Header menggunakan # agar terdeteksi navigasi UI
        output.write("# Cisco ASA Configuration generated by Firewall Converter\n\n")

        self._generate_interfaces(output)
        self._generate_addresses(output)
        self._generate_services(output)
        self._generate_address_groups(output)
        self._generate_service_groups(output)
        self._generate_static_routes(output)
        self._generate_nat_rules(output)
        self._generate_rules(output)

        return output.getvalue()

    def _generate_interfaces(self, f):
        """Men-generate perintah untuk membuat interface dan subinterface."""
        if not self.config.interfaces: return
        f.write("# --- Interface ---\n")

        # [NEW] Helper to get mapped interface name
        def get_mapped_name(original_name):
            if original_name in self.interface_mapping:
                val = self.interface_mapping[original_name]
                if isinstance(val, dict):
                     val = val.get('target_interface')

                if val and str(val).strip():
                    return val
            return original_name

        # Urutkan agar parent interface muncul sebelum subinterface (opsional, tapi rapi)
        for iface in sorted(self.config.interfaces, key=lambda x: x.name):
            # [FIXED] Interface name is ALREADY renamed by app.py, use it directly
            f.write(f"interface {iface.name}\n")

            # --- Description ---
            if iface.description:
                f.write(f" description {iface.description}\n")

            # --- VLAN Handling for Subinterfaces ---
            # Cisco ASA mewajibkan 'vlan {id}' untuk subinterface agar nameif berfungsi.
            # Kita coba ambil dari properti vlan_id, atau ekstrak dari nama (misal .100)
            vlan_id = iface.vlan_id

            if not vlan_id and '.' in iface.name:
                try:
                    # Coba ekstrak angka setelah titik terakhir (from original name for VLAN ID)
                    parts = iface.name.rsplit('.', 1)
                    if len(parts) == 2 and parts[1].isdigit():
                        vlan_id = parts[1]
                except:
                    pass

            if vlan_id:
                f.write(f" vlan {vlan_id}\n")

            # --- Zone / Nameif Handling ---
            # FIX: Prioritaskan iface.zone. Jika kosong, gunakan nama interface yang disanitasi.
            nameif_val = iface.zone
            if not nameif_val:
                # Fallback: Buat nama zone dari mapped interface name
                nameif_val = self._sanitize_name(mapped_name)[:48]

            f.write(f" nameif {nameif_val}\n")

            # Auto-detect security level based on zone name
            sec_lvl = 0
            z_lower = nameif_val.lower()
            if 'inside' in z_lower or 'trust' in z_lower or 'lan' in z_lower:
                sec_lvl = 100
            elif 'dmz' in z_lower:
                sec_lvl = 50
            f.write(f" security-level {sec_lvl}\n")

            # --- IP Address ---
            if iface.ip_address and iface.mask_length:
                ip_mask = self._cidr_to_mask(str(iface.mask_length))
                f.write(f" ip address {iface.ip_address} {ip_mask}\n")

            f.write(" no shutdown\n")
        f.write("\n")

    def _generate_static_routes(self, f):
        """Men-generate perintah 'route' dari objek StaticRoute."""
        if not self.config.static_routes: return
        f.write("# --- Routes ---\n")
        for route in self.config.static_routes:
            try:
                dest_ip, cidr = route.destination.split('/')
                dest_mask = self._cidr_to_mask(cidr)
                iface = route.interface or "outside"
                cmd = f"route {iface} {dest_ip} {dest_mask} {route.next_hop}"
                if route.distance and route.distance != 1:
                    cmd += f" {route.distance}"
                f.write(cmd + "\n")
            except (ValueError, TypeError):
                f.write(f"! SKIPPED INVALID ROUTE: {route}\n")
        f.write("\n")

    def _generate_addresses(self, f):
        if not self.config.addresses: return
        f.write("# --- Object Address ---\n")
        for addr in sorted(self.config.addresses, key=lambda x: x.name):
            # Apply Sanitization
            clean_name = self._sanitize_name(addr.name)

            f.write("object network {}\n".format(clean_name))
            if addr.type == 'host':
                f.write(" host {}\n".format(addr.value1))
            elif addr.type == 'network':
                netmask = self._cidr_to_mask(addr.value2)
                f.write(" subnet {} {}\n".format(addr.value1, netmask))
            elif addr.type == 'range':
                f.write(" range {} {}\n".format(addr.value1, addr.value2))
        f.write("\n")

    def _generate_services(self, f):
        if not self.config.services: return
        f.write("# --- Object Service ---\n")
        for svc in sorted(self.config.services, key=lambda x: x.name):
            if svc.protocol.lower() not in ['tcp', 'udp', 'icmp']: continue

            # Apply Sanitization
            clean_name = self._sanitize_name(svc.name)

            f.write("object service {}\n".format(clean_name))

            # Clean port string (remove 'eq ' artifact if present in raw string)
            # Example: "eq 80" -> "80", "80-90" -> "80 90" (replace - with space for range)
            raw_port = svc.port.replace('eq ', '')
            port_str = raw_port.replace('-', ' ')

            # Logic untuk range vs single port
            if ' ' in port_str:
                f.write(" service {} destination range {}\n".format(svc.protocol.lower(), port_str))
            else:
                f.write(" service {} destination eq {}\n".format(svc.protocol.lower(), port_str))
        f.write("\n")

    def _generate_address_groups(self, f):
        if not self.config.address_groups: return
        f.write("# --- Address Group ---\n")
        for grp in sorted(self.config.address_groups, key=lambda x: x.name):
            clean_grp_name = self._sanitize_name(grp.name)
            f.write("object-group network {}\n".format(clean_grp_name))
            for member in sorted(list(grp.members)):
                clean_member = self._sanitize_name(member)
                # Check logic: we can't easily verify if member is address or group here without lookup,
                # but ASA usually accepts network-object object X or group-object Y.
                # Simplified: try to match against known addresses
                member_obj = next((a for a in self.config.addresses if self._sanitize_name(a.name) == clean_member),
                                  None)
                if member_obj:
                    f.write(" network-object object {}\n".format(clean_member))
                else:
                    f.write(" group-object {}\n".format(clean_member))
        f.write("\n")

    def _generate_service_groups(self, f):
        if not self.config.service_groups: return
        f.write("# --- Service Group ---\n")
        for grp in sorted(self.config.service_groups, key=lambda x: x.name):
            clean_grp_name = self._sanitize_name(grp.name)
            f.write("object-group service {}\n".format(clean_grp_name))
            for member in sorted(list(grp.members)):
                clean_member = self._sanitize_name(member)
                f.write(" service-object object {}\n".format(clean_member))
        f.write("\n")

    def _generate_nat_rules(self, f):
        if not self.config.nat_rules: return
        f.write("# --- NAT ---\n")
        objects_with_nat = set()
        manual_nat_rules = [r for r in self.config.nat_rules if r.translated_source and r.translated_destination]
        object_nat_rules = [r for r in self.config.nat_rules if not (r.translated_source and r.translated_destination)]

        if manual_nat_rules:
            f.write("! Manual NAT Rules (Twice NAT)\n")
            for i, rule in enumerate(self.config.nat_rules):
                if rule in manual_nat_rules:
                    src_intf = list(rule.source_interface)[0] if rule.source_interface else 'any'
                    dst_intf = list(rule.destination_interface)[0] if rule.destination_interface else 'any'

                    # Sanitize object references
                    orig_src = self._sanitize_name(list(rule.original_source)[0])
                    orig_dst = self._sanitize_name(list(rule.original_destination)[0])
                    trans_src = self._sanitize_name(rule.translated_source)
                    trans_dst = self._sanitize_name(rule.translated_destination)

                    cmd = "nat ({},{}) {} ".format(src_intf, dst_intf, i + 1)
                    cmd += "source static {} {} ".format(orig_src, trans_src)
                    cmd += "destination static {} {}".format(orig_dst, trans_dst)
                    f.write(cmd + "\n")
            f.write("\n")

        if object_nat_rules:
            f.write("! Object NAT Rules\n")
            for rule in object_nat_rules:
                src_intf = list(rule.source_interface)[0] if rule.source_interface else 'any'
                dst_intf = list(rule.destination_interface)[0] if rule.destination_interface else 'any'

                if rule.translated_source and rule.original_source:
                    original_source_obj_name = self._sanitize_name(list(rule.original_source)[0])
                    translated_source = self._sanitize_name(rule.translated_source)

                    if original_source_obj_name not in objects_with_nat:
                        f.write("object network {}\n".format(original_source_obj_name))
                        f.write(
                            " nat ({},{}) dynamic {}\n".format(src_intf, dst_intf,
                                                               translated_source))
                        objects_with_nat.add(original_source_obj_name)

                elif rule.translated_destination and rule.original_destination:
                    original_dest_obj_name = self._sanitize_name(list(rule.original_destination)[0])
                    translated_dest = self._sanitize_name(rule.translated_destination)

                    if original_dest_obj_name not in objects_with_nat:
                        f.write("object network {}\n".format(original_dest_obj_name))
                        f.write(
                            " nat ({},{}) static {}\n".format(dst_intf, src_intf,
                                                              translated_dest))
                        objects_with_nat.add(original_dest_obj_name)
            f.write("\n")

    def _format_address(self, addr_name: str) -> str:
        if addr_name.lower() in ['any', 'all']:
            return 'any'

        # Sanitize input name
        clean_addr_name = self._sanitize_name(addr_name)

        is_group = any(self._sanitize_name(g.name) == clean_addr_name for g in self.config.address_groups)
        if is_group:
            return "object-group {}".format(clean_addr_name)
        return "object {}".format(clean_addr_name)

    def _generate_rules(self, f):
        if not self.config.rules: return
        f.write("# --- ACLs ---\n")

        # --- [NEW] Build DNAT Map for Post-NAT Destination Resolution ---
        # Cisco ASA 8.3+ ACLs match Real IP (Post-NAT), not VIP (Pre-NAT).
        # We need to map: Original Destination (VIP) -> Translated Destination (Real IP)
        dnat_map = {}
        for nat in self.config.nat_rules:
            if nat.translated_destination and nat.original_destination:
                # Assuming 1-to-1 mapping for simplicity in this context
                orig = list(nat.original_destination)[0]
                trans = nat.translated_destination
                dnat_map[orig] = trans

        rules_by_interface = defaultdict(list)
        for rule in self.config.rules:
            if not rule.source_interface or 'any' in {iface.lower() for iface in rule.source_interface}:
                rules_by_interface['global_access'].append(rule)
            else:
                for iface in rule.source_interface:
                    rules_by_interface[iface].append(rule)

        for iface_name in sorted(rules_by_interface.keys()):
            clean_iface_name = re.sub(r'[^\w-]', '_', iface_name)
            acl_name = "{}_access_in".format(clean_iface_name)

            for rule in rules_by_interface[iface_name]:
                action = "permit" if rule.action in ["allow", "permit", "accept"] else "deny"

                src_list = sorted(list(rule.source))
                src_str = " ".join([self._format_address(s) for s in src_list]) if src_list else "any"

                # --- [NEW] Resolve Destination Address (Pre-NAT -> Post-NAT) ---
                resolved_destinations = set()
                for dst in rule.destination:
                    # Check if this destination is a VIP (Pre-NAT) that needs translation to Real IP (Post-NAT)
                    if dst in dnat_map:
                        resolved_destinations.add(dnat_map[dst])
                    else:
                        resolved_destinations.add(dst)
                
                dst_list = sorted(list(resolved_destinations))
                dst_str = " ".join([self._format_address(d) for d in dst_list]) if dst_list else "any"

                services_to_generate = set()
                ANY_SERVICE_NAMES = {'any', 'all'}
                explicit_services = {s for s in rule.service if
                                     s.lower() not in ANY_SERVICE_NAMES and s.lower() != 'application-default'}
                if explicit_services:
                    services_to_generate.update(explicit_services)

                # Handle Apps mapping to ports if no explicit service
                if not services_to_generate and rule.application:
                    for app_name in rule.application:
                        if app_name.lower() in self._APP_TO_SERVICE_MAP:
                            mapped_service = self._APP_TO_SERVICE_MAP[app_name.lower()]
                            # Add mapped service to config if not exists
                            if not any(s.name == mapped_service.name for s in self.config.services):
                                self.config.services.add(mapped_service)
                            services_to_generate.add(mapped_service.name)

                if not services_to_generate:
                    if rule.application:
                        services_to_generate.add('ip')
                    else:
                        services_to_generate.add('any')

                for svc_name in sorted(list(services_to_generate)):
                    # Sanitize service name
                    clean_svc_name = self._sanitize_name(svc_name)

                    if clean_svc_name.lower() in ['any', 'ip']:
                        f.write("access-list {} extended {} ip {} {}\n".format(acl_name, action, src_str, dst_str))
                        continue

                    # Lookup sanitized
                    svc_obj = next((s for s in self.config.services if self._sanitize_name(s.name) == clean_svc_name),
                                   None)
                    svc_grp = next(
                        (g for g in self.config.service_groups if self._sanitize_name(g.name) == clean_svc_name), None)

                    if svc_obj:
                        port_str = svc_obj.port.replace('eq ', '').replace('-', ' ')
                        op = "range" if ' ' in port_str else "eq"
                        f.write(
                            "access-list {} extended {} {} {} {} {} {}\n".format(acl_name, action, svc_obj.protocol,
                                                                                 src_str, dst_str, op, port_str))
                    elif svc_grp:
                        f.write(
                            "access-list {} extended {} object-group {} {} {}\n".format(acl_name, action,
                                                                                        clean_svc_name,
                                                                                        src_str, dst_str))
            f.write("\n")

        f.write("! Applying ACLs to Interfaces\n")
        if 'global_access' in rules_by_interface:
            f.write(
                "! Note: The following 'global_access_in' ACL was generated from rules with 'any' as source interface.\n")
            f.write("! Please apply it manually to the relevant outside/internet-facing interface(s).\n")
            f.write("! Example: access-group global_access_in in interface outside\n\n")

        for iface_name in sorted(rules_by_interface.keys()):
            if iface_name == 'global_access':
                continue

            # Cari nama zona (nameif) dari objek interface (sudah ter-mapping di app.py)
            iface_obj = next((i for i in self.config.interfaces if i.name == iface_name), None)
            zone_name = iface_obj.zone if iface_obj and iface_obj.zone else iface_name

            clean_iface_name = re.sub(r'[^\w-]', '_', iface_name)
            acl_name = "{}_access_in".format(clean_iface_name)
            f.write("access-group {} in interface {}\n".format(acl_name, zone_name))
        f.write("\n")