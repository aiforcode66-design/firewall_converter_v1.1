# -*- coding: utf-8 -*-
"""
File ini berisi generator untuk konfigurasi Juniper SRX.
Updated:
1. FIXED: Security Policies now correctly use Pre-NAT (Original IP) for Destination Address
   when DNAT is involved. This handles input from Post-NAT sources (like Cisco ASA).
"""
import io
import re
from collections import defaultdict

from models import FirewallConfig, Address, Group, Service, ServiceGroup, Rule, NatRule, StaticRoute, Interface
from .base import BaseGenerator


class JuniperSrxGenerator(BaseGenerator):
    """Generator untuk skrip konfigurasi Juniper SRX."""
    _RE_CLEAN_NAME = re.compile(r'[^\w-]')

    def generate(self) -> str:
        """Menghasilkan skrip Juniper SRX lengkap."""
        self.address_map = {addr.name: addr for addr in self.config.addresses}

        output = io.StringIO()
        output.write("# Juniper SRX Configuration generated by Firewall Converter\n")
        output.write("# Please review and adjust as necessary.\n\n")

        self._generate_interfaces_and_zones(output)
        self._generate_addresses(output)
        self._generate_services(output)
        self._generate_static_routes(output)
        self._generate_nat_rules(output)
        self._generate_rules(output)

        return output.getvalue()

    def _generate_interfaces_and_zones(self, f):
        """Men-generate perintah untuk membuat interface dan zona."""
        if not self.config.interfaces: return

        f.write("# --- Interface ---\n")
        for iface in sorted(self.config.interfaces, key=lambda x: x.name):
            if iface.ip_address and iface.mask_length:
                f.write(
                    f"set interfaces {iface.name} unit 0 family inet address {iface.ip_address}/{iface.mask_length}\n")
        f.write("\n")

        f.write("# --- Zone ---\n")
        zones_with_members = defaultdict(list)
        for iface in self.config.interfaces:
            if iface.zone:
                zones_with_members[iface.zone].append(f"{iface.name}.0")

        for zone_name, members in zones_with_members.items():
            f.write(f"set security zones security-zone {zone_name}\n")
            if members:
                members_str = " ".join(sorted(members))
                f.write(f"set security zones security-zone {zone_name} interfaces [ {members_str} ]\n")
        f.write("\n")

    def _generate_static_routes(self, f):
        """Men-generate perintah rute statis untuk Juniper SRX."""
        if not self.config.static_routes: return
        f.write("# --- Routes ---\n")
        for route in self.config.static_routes:
            f.write(f"set routing-options static route {route.destination} next-hop {route.next_hop}\n")
        f.write("\n")

    def _generate_addresses(self, f):
        if not self.config.addresses: return
        f.write("# --- Object Address ---\n")
        f.write("edit security address-book global\n")
        for addr in sorted(self.config.addresses, key=lambda x: x.name):
            clean_name = self._RE_CLEAN_NAME.sub('_', addr.name)
            if addr.type == 'host':
                f.write("set address {} {}/32\n".format(clean_name, addr.value1))
            elif addr.type == 'network':
                f.write("set address {} {}/{}\n".format(clean_name, addr.value1, addr.value2))
            elif addr.type == 'range':
                f.write("set address {} range-address {} to {}\n".format(clean_name, addr.value1, addr.value2))

        if self.config.address_groups:
            f.write("\n# --- Address Group ---\n")
            for grp in sorted(self.config.address_groups, key=lambda x: x.name):
                clean_name = self._RE_CLEAN_NAME.sub('_', grp.name)
                f.write("set address-set {}\n".format(clean_name))
                for member in sorted(list(grp.members)):
                    clean_member = self._RE_CLEAN_NAME.sub('_', member)
                    f.write("set address-set {} address {}\n".format(clean_name, clean_member))
        f.write("top\n\n")

    def _generate_services(self, f):
        if not self.config.services: return
        f.write("# --- Object Service ---\n")
        for svc in sorted(self.config.services, key=lambda x: x.name):
            clean_name = self._RE_CLEAN_NAME.sub('_', svc.name)
            protocol = svc.protocol.lower()
            if protocol in ['tcp', 'udp']:
                port_val = svc.port.split()[-1]
                f.write("set applications application {} protocol {} destination-port {}\n".format(clean_name, protocol,
                                                                                                   port_val))

        if self.config.service_groups:
            f.write("\n# --- Service Group ---\n")
            for grp in sorted(self.config.service_groups, key=lambda x: x.name):
                clean_name = self._RE_CLEAN_NAME.sub('_', grp.name)
                f.write("set applications application-set {}\n".format(clean_name))
                for member in sorted(list(grp.members)):
                    clean_member = self._RE_CLEAN_NAME.sub('_', member)
                    f.write("set applications application-set {} application {}\n".format(clean_name, clean_member))
        f.write("\n")

    def _generate_nat_rules(self, f):
        if not self.config.nat_rules: return
        f.write("# --- NAT ---\n")

        f.write("# NAT Pools\n")
        created_pools = set()
        for rule in self.config.nat_rules:
            if rule.translated_source and rule.translated_source not in created_pools:
                pool_name = rule.translated_source
                addr_obj = self.address_map.get(pool_name)

                if addr_obj:
                    if addr_obj.type == 'host':
                        f.write("set security nat source pool {} address {}/32\n".format(pool_name, addr_obj.value1))
                    elif addr_obj.type == 'network':
                        f.write(
                            "set security nat source pool {} address {}/{}\n".format(pool_name, addr_obj.value1,
                                                                                     addr_obj.value2))
                    elif addr_obj.type == 'range':
                        f.write(
                            "set security nat source pool {} address range {} to {}\n".format(pool_name,
                                                                                              addr_obj.value1,
                                                                                              addr_obj.value2))
                else:
                    f.write("set security nat source pool {} address {}/32\n".format(pool_name, pool_name))
                created_pools.add(pool_name)

            if rule.translated_destination and rule.translated_destination not in created_pools:
                pool_name = rule.translated_destination
                addr_obj = self.address_map.get(pool_name)

                if addr_obj:
                    if addr_obj.type == 'host':
                        f.write(
                            "set security nat destination pool {} address {}/32\n".format(pool_name, addr_obj.value1))
                    elif addr_obj.type == 'network':
                        f.write(
                            "set security nat destination pool {} address {}/{}\n".format(pool_name, addr_obj.value1,
                                                                                          addr_obj.value2))
                    elif addr_obj.type == 'range':
                        f.write(
                            "set security nat destination pool {} address range {} to {}\n".format(pool_name,
                                                                                                   addr_obj.value1,
                                                                                                   addr_obj.value2))
                else:
                    f.write("set security nat destination pool {} address {}/32\n".format(pool_name, pool_name))
                created_pools.add(pool_name)
        f.write("\n")

        for rule in self.config.nat_rules:
            from_zones = sorted(list(rule.source_interface))
            to_zones = sorted(list(rule.destination_interface))

            for from_zone in from_zones:
                for to_zone in to_zones:
                    rule_set_name = "rs_{}_{}".format(from_zone, to_zone)

                    if rule.translated_source:
                        f.write(
                            "set security nat source rule-set {} from zone {}\n".format(rule_set_name, from_zone))
                        f.write("set security nat source rule-set {} to zone {}\n".format(rule_set_name, to_zone))
                        f.write("set security nat source rule-set {} rule {}\n".format(rule_set_name, rule.name))

                        src_list = sorted(list(rule.original_source))
                        src_addr = "any" if not src_list or 'any' in {s.lower() for s in src_list} else " ".join(
                            [self._RE_CLEAN_NAME.sub('_', s) for s in src_list])
                        f.write(
                            "set security nat source rule-set {} rule {} match source-address {}\n".format(
                                rule_set_name,
                                rule.name, src_addr))

                        dst_list = sorted(list(rule.original_destination))
                        dst_addr = "any" if not dst_list or 'any' in {d.lower() for d in dst_list} else " ".join(
                            [self._RE_CLEAN_NAME.sub('_', d) for d in dst_list])
                        f.write(
                            "set security nat source rule-set {} rule {} match destination-address {}\n".format(
                                rule_set_name,
                                rule.name,
                                dst_addr))

                        f.write(
                            "set security nat source rule-set {} rule {} then source-nat pool {}\n".format(
                                rule_set_name,
                                rule.name,
                                rule.translated_source))

                    if rule.translated_destination and not rule.translated_source:
                        f.write("set security nat destination rule-set {} from zone {}\n".format(rule_set_name,
                                                                                                 from_zone))
                        f.write("set security nat destination rule-set {} rule {}\n".format(rule_set_name, rule.name))

                        dst_list = sorted(list(rule.original_destination))
                        dst_addr = "any" if not dst_list or 'any' in {d.lower() for d in dst_list} else " ".join(
                            [self._RE_CLEAN_NAME.sub('_', d) for d in dst_list])
                        f.write(
                            "set security nat destination rule-set {} rule {} match destination-address {}\n".format(
                                rule_set_name, rule.name, dst_addr))

                        f.write(
                            "set security nat destination rule-set {} rule {} then destination-nat pool {}\n".format(
                                rule_set_name, rule.name, rule.translated_destination))
            f.write("\n")

    def _generate_rules(self, f):
        if not self.config.rules: return
        f.write("# --- Security Policy ---\n")

        # --- [NEW] Build Reverse DNAT Map (Translated -> Original) ---
        # Juniper SRX Security Policies match Pre-NAT IP (Original Destination).
        # We need to map: Translated Destination (Real IP) -> Original Destination (VIP)
        # This handles input from Post-NAT sources (like Cisco ASA).
        dnat_reverse_map = {}
        for nat in self.config.nat_rules:
            if nat.translated_destination and nat.original_destination:
                # Assuming 1-to-1 mapping
                trans = nat.translated_destination
                orig = list(nat.original_destination)[0]
                dnat_reverse_map[trans] = orig

        for rule in self.config.rules:
            from_zones = sorted(list(rule.source_interface))
            to_zones = sorted(list(rule.destination_interface))

            for from_zone in from_zones:
                for to_zone in to_zones:
                    policy_name = self._RE_CLEAN_NAME.sub('_', f"{rule.name}_{from_zone}_{to_zone}")

                    f.write("set security policies from-zone {} to-zone {} policy {}\n".format(from_zone, to_zone,
                                                                                               policy_name))

                    src_list = sorted(list(rule.source))
                    src_addr = "any" if not src_list or 'any' in {s.lower() for s in src_list} else " ".join(
                        [self._RE_CLEAN_NAME.sub('_', s) for s in src_list])
                    f.write(
                        "set security policies from-zone {} to-zone {} policy {} match source-address [ {} ]\n".format(
                            from_zone, to_zone, policy_name, src_addr))

                    # --- [NEW] Resolve Destination Address (Post-NAT -> Pre-NAT) ---
                    resolved_destinations = set()
                    for dst in rule.destination:
                        # Check if this destination is a Real IP (Post-NAT) that needs to be mapped back to VIP (Pre-NAT)
                        if dst in dnat_reverse_map:
                            resolved_destinations.add(dnat_reverse_map[dst])
                        else:
                            resolved_destinations.add(dst)

                    dst_list = sorted(list(resolved_destinations))
                    dst_addr = "any" if not dst_list or 'any' in {d.lower() for d in dst_list} else " ".join(
                        [self._RE_CLEAN_NAME.sub('_', d) for d in dst_list])
                    f.write(
                        "set security policies from-zone {} to-zone {} policy {} match destination-address [ {} ]\n".format(
                            from_zone, to_zone, policy_name, dst_addr))

                    svc_list = sorted(list(rule.service))
                    app_list = sorted(list(rule.application))

                    final_apps = set()

                    if app_list:
                        final_apps.update(app_list)
                        is_app_default = 'application-default' in {s.lower() for s in svc_list}
                        if not is_app_default and svc_list and 'any' not in {s.lower() for s in svc_list}:
                            final_apps.update(svc_list)
                    else:
                        final_apps.update(svc_list)

                    final_apps_list = sorted(list(final_apps))
                    if not final_apps_list or 'any' in {s.lower() for s in
                                                        final_apps_list} or 'application-default' in {
                        s.lower() for s in final_apps_list}:
                        app_str = "any"
                    else:
                        app_map = {'tcp-80': 'junos-http', 'tcp-443': 'junos-https', 'tcp-22': 'junos-ssh'}
                        cleaned_apps = [app_map.get(s, self._RE_CLEAN_NAME.sub('_', s)) for s in final_apps_list]
                        app_str = " ".join(cleaned_apps)

                    f.write(
                        "set security policies from-zone {} to-zone {} policy {} match application [ {} ]\n".format(
                            from_zone,
                            to_zone,
                            policy_name,
                            app_str))

                    action = "permit" if rule.action == "allow" else "deny"
                    f.write(
                        "set security policies from-zone {} to-zone {} policy {} then {}\n".format(from_zone, to_zone,
                                                                                                   policy_name, action))

                    if not rule.enabled:
                        f.write("deactivate security policies from-zone {} to-zone {} policy {}\n".format(from_zone,
                                                                                                          to_zone,
                                                                                                          policy_name))
            f.write("\n")
